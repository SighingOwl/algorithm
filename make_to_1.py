'''
# 시간 복잡도
    - DP를 초기화하는데 n + 1번의 반복이 필요하므로 O(n)의 시간 복잡도가 필요
    - DP[i]에 DP[i - 1] + 1을 저장하든가 if문의 비교 연산은 모두 상수시간에 가능하므로 O(1)의 시간 복잡도를 가진다.
    - min 함수는 일반적으로 O(n)의 시간 복잡도를 가지고 있으나 두 요소에 대한 비교를 하므로 O(1)에 근접한다.
    - for loop안의 각 요소들의 수행 시간이 O(1)이고 loop의 횟수가 n - 1이므로 전체 알고리즘의 시간 복잡도는 O(n)이 된다.
'''

n = int(input())

DP = [0 for i in range(n + 1)] # 0부터 n까지 각각의 숫자에 대한 최소 연산 횟수를 저장하는 DP 테이블

for i in range(2, n + 1):   # 0, 1은 연산 횟수가 0번이므로 2부터 반복한다.
    DP[i] = DP[i - 1] + 1   # -1을 하는 연산 횟수를 1 추가
    
    if i % 2 == 0:  # i는 DP의 인덱스이기도 하자만 현재 검사 중인 정수를 의미하기도 하므로 현재 검사 중인 정수가 2의 배수 일 때 이전 2의 배수의 횟수에 1을 더한 연산 횟수와 -1을 한 연산 횟수 중 최소값은 DP 테이블의 마지막 값으로 저장
        DP[i] = min(DP[i], DP[i // 2] + 1)
    
    if i % 3 == 0: # 현재 검사 중인 정수가 3의 배수 일 때 -1 혹은 /2를 했을 때 연산 횟수와 /3을 한 연산 횟수 중 최소 연산 횟수를 DP 테이블 마지막 값으로 저장.
        DP[i] = min(DP[i], DP[i // 3] + 1)

print(DP[n]) # 인덱스가 n에 n에 대한 최소 연산 횟수 저장하므로 DP[n]을 호출